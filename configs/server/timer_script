#!/usr/bin/env bash
#
# Script that determines whether it is time to run a backup.

echo "Running timer script: $@"

client="$1" ; shift
current="$1" ; shift
storage_dir="$1" ; shift
reserved1="$1" ; shift
reserved2="$1" ; shift
interval="$1" ; shift
timestamp="$current/timestamp"
date --version 2>&1|grep -qv coreutils
gnu_date=$?

# A 'backup' file placed in the storage directory tells this script that
# a backup needs to be done right now.
# This gives the 'server initiates a manual backup' feature.

manual_file="$storage_dir/$client/backup"
if [ -f "$manual_file" ] ; then
	echo "Found $manual_file"
	echo "Do a backup of $client now"
	rm -f "$manual_file"
	exit 0
fi

# The rest of the arguments, if any, should be timebands.
# Set LANG=C and LC_TIME=C so that 'date' returns English day names.
curdayhour=$(LANG=C LC_TIME=C date +"*%a*%H*")
intimeband=0 # If no timebands given, default to not OK.
while [ "$#" -gt 0 ] ; do
	intimeband=0
	timeband="$1"
	case "$timeband" in
		$curdayhour|always)
			echo "In timeband: $timeband"
			intimeband=1
			break
			;;
		*)
			echo "Out of timeband: $timeband"
			;;
	esac
	shift
done

datefail()
{
	echo "$0: Date command returned error for $client."
	exit 1;
}

get_intervals()
{
	if [ ! -e "$current" ] ; then
		echo "No prior backup of $client"
		return 0
	fi
	if [ ! -f "$timestamp" ] ; then
		echo "$0: Timestamp file missing for $client."
		return 0
	fi
	if [ -z "$interval" ] ; then
		echo "$0: No time interval given for $client."
		return 0
	fi

	case "$interval" in
	  [0-9]*s) i=${interval%s*} ; intervalsecs=$i ;;
	  [0-9]*m) i=${interval%m*} ; intervalsecs=$((i*60)) ;;
	  [0-9]*h) i=${interval%h*} ; intervalsecs=$((i*60*60)) ;;
	  [0-9]*d) i=${interval%d*} ; intervalsecs=$((i*60*60*24)) ;;
	  [0-9]*w) i=${interval%w*} ; intervalsecs=$((i*60*60*24*7)) ;;
	  [0-9]*n) i=${interval%n*} ; intervalsecs=$((i*60*60*24*30)) ;;
	  *) echo "$0: interval $interval not understood for $client."
		return 0 ;;
	esac

	if [ -z "$intervalsecs" ] ; then
		echo "$0: interval $interval not understood for $client."
		return 0
	fi

	read junk ts < "$timestamp"

	if [ $gnu_date == 1 ] ; then
		secs=$(LANG=C LC_TIME=C date +%s -d "$ts")
	# Only FreeBSD's date(1) have a way to specify input format
	elif [ "$(uname -s)" == "FreeBSD" ] ; then
		secs=$(LANG=C LC_TIME=C date -j -f '%F %T' "$ts" +%s)
	else
		mts=$(echo $ts | sed -e 's/-//g; s/ //; s/://; s/:/./')
		secs=$(LANG=C LC_TIME=C date -j "$mts" +%s)
	fi
	[ $? != 0 ] && datefail

	now=$(LANG=C LC_TIME=C date +"%Y-%m-%d %H:%M:%S")
	nowsecs=$(LANG=C LC_TIME=C date +%s)
	min_timesecs=$((secs+intervalsecs))
	if [ $gnu_date == 1 ] ; then
		min_time=$(LANG=C LC_TIME=C date -d "Jan 1, 1970 00:00:00 +0000 + $min_timesecs seconds" +"%Y-%m-%d %H:%M:%S")
	else
		min_time=$(LANG=C LC_TIME=C date -r $min_timesecs +"%Y-%m-%d %H:%M:%S")
	fi
	[ $? != 0 ] && datefail

	echo "Last backup: $ts"
	echo "Next after : $min_time (interval $interval)"

	return 1
}

if [ "$intimeband" = "0" ] ; then
	get_intervals
	exit 1
fi

if get_intervals ; then
	echo "Do a backup of $client now."
	exit 0
fi

if [ "$min_timesecs" -lt "$nowsecs" ] ; then
	echo "$min_time < $now."
	echo "Do a backup of $client now."
	exit 0
fi

echo "Not yet time for a backup of $client"

exit 1
